# Некоторые числа имеют забавные свойства.
# Например:
#     89 --> 8¹ + 9² = 89 * 1
#     695 --> 6² + 9³ + 5⁴ = 1390 = 695 * 2
#     46288 --> 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51

# Имея два положительных целых числа n и p, мы хотим найти целое положительное число k,
# если оно существует. Такое, что сумма цифр n, возведенных в последовательные степени,
# начиная с p, равна k * n. (k = sum (n**p+i) // n)

# Если это так, мы вернем k, если нет, вернем -1.

# Примечание. n и p всегда будут строго положительными целыми числами.

def big_pow(n, p):
    digits = list(map(int, str(n))) #преобразуем n в строку, а после каждый симов обратно в int.
    total = sum(numb ** (p + i) for i, numb in enumerate(digits)) # Основная формула в коде
    if total % n == 0:
        return total // n
    else:
        return -1

n = 46288
p = 3 # Задаем сами, хз откуда берется.

test = big_pow(n, p)
print(test)
